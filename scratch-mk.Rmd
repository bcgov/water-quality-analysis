---
title: "R Notebook"
output: html_notebook
---

```{r setup, include=FALSE}
library(canwqdata)
library(dplyr)
library(ggplot2)
library(lubridate)
library(wqbc)
library(readr)
library(here)
library(feather)
library(purrr)
source(here::here("R/functions.R"))
dir.create(here::here("out"))
```

```{r EC-data}
bc_nested <- readRDS(here("tmp/bc_nested.rds"))

```

Create a monthly data frame and subset to one parameter (arsenic):

```{r}
fraser_hope_arsenic <- filter(bc_nested, 
                              SITE_NO == "BC08MF0001",
                              PARAM_SHORT_NAME == "ARSENIC TOTAL") %>% 
  pull(full_monthly) %>% 
  `[[`(1)

ggplot(fraser_hope_arsenic, aes(x = Date, y = month_avg)) + 
  geom_point() + 
  geom_line() +
  geom_smooth(method = "lm")
```



Testing out USGS seaken method:
```{r}
library(smwrStats)
library(smwrGraphs)

fraser_hope_arsenic_sk <- seaken(fraser_hope_arsenic$month_avg)
fraser_hope_arsenic_sk
seriesPlot(fraser_hope_arsenic_sk)

# non-seasonal - to get an intercept estimate. A bit of a hack, but don't know
# a better way
fraser_hope_arsenic_k <- kensen.test(fraser_hope_arsenic$month_avg, t = as.numeric(fraser_hope_arsenic$Date)
)

slope <- fraser_hope_arsenic_sk$estimate["slope"] / (365 / 12)

int <- fraser_hope_arsenic_k$coef[1] - 
  (slope * min(as.numeric(fraser_hope_arsenic$Date)))

ggplot(fraser_hope_arsenic, aes(x = Date, y = month_avg)) + 
  geom_point() + 
  geom_abline(slope = slope, intercept = int)

```


EnvStats:

```{r}
library(EnvStats)

ks_fraser <- kendallSeasonalTrendTest(month_avg ~ month + year, 
                                      data = fraser_hope_arsenic)

ks_fraser
# In order to account for serial autocorrelation there must be the same number
# of observations in each year (12) - could either pad start and end years 
# with NAs or truncate.
```

Plot the Seasonal Kendall results: need to rescale the slope and intercept 
because they are based on time starting at time zero, and incrementing up by month.
The date scale starts at `as.numeric(min(fraser_hope_arsenic$Date))` and increments
by one per day

```{r}
slope <- ks_fraser$estimate["slope"] / (365 / 12)
# The overall intercept is the median of all seasonal intercepts... doesn't seem
# right
int <- ks_fraser$estimate["intercept"] - 
  (slope * min(as.numeric(fraser_hope_arsenic$Date)))
  

ggplot(fraser_hope_arsenic, aes(x = Date, y = month_avg)) + 
  geom_point() + 
  geom_abline(slope = slope, 
              intercept = int)

# plotting on a sequence scale (as the MK test is done on) produces the same 
# figure, so I think I am transforming the slope and intercept correctly.
plot(fraser_hope_arsenic$month_avg ~ seq_len(nrow(fraser_hope_arsenic)))
abline(ks_fraser$estimate["intercept"], ks_fraser$estimate["slope"])

```

