---
title: "R Notebook"
output: html_notebook
---

```{r setup, include=FALSE}
library(canwqdata)
library(dplyr)
library(ggplot2)
library(lubridate)
library(wqbc)
library(readr)
library(here)
library(feather)
library(purrr)
source(here::here("R/functions.R"))
dir.create(here::here("out"))
```

```{r EC-data}
bc_nested <- readRDS(here("tmp/bc_nested.rds"))

```

Create a monthly data frame and subset to one parameter (arsenic):

```{r}
fraser_hope_arsenic <- filter(bc_nested, 
                              SITE_NO == "BC08MF0001",
                              PARAM_SHORT_NAME == "ARSENIC TOTAL") %>% 
  pull(full_monthly) %>% 
  pluck(1)

ggplot(fraser_hope_arsenic, aes(x = Date, y = month_avg)) + 
  geom_point() + 
  geom_line() +
  geom_smooth(method = "lm")
```



Testing out USGS seaken method:
```{r}
library(smwrStats)
library(smwrGraphs)

fraser_hope_arsenic_sk <- seaken(fraser_hope_arsenic$month_avg)
fraser_hope_arsenic_sk
# seriesPlot(fraser_hope_arsenic_sk)

# non-seasonal - to get an intercept estimate. A bit of a hack, but don't know
# a better way
fraser_hope_arsenic_k <- kensen.test(fraser_hope_arsenic$month_avg, 
                                     t = as.numeric(fraser_hope_arsenic$Date)
)

slope <- fraser_hope_arsenic_sk$estimate["slope"] / 365

int <- fraser_hope_arsenic_k$coef[1] - 
  (slope * min(as.numeric(fraser_hope_arsenic$Date)))

ggplot(fraser_hope_arsenic, aes(x = Date, y = month_avg)) + 
  geom_point() + 
  geom_abline(slope = slope, intercept = int)

```


EnvStats:

```{r}
library(EnvStats)

ks_fraser <- kendallSeasonalTrendTest(month_avg ~ month + year, 
                                      data = fraser_hope_arsenic)

ks_fraser
# In order to account for serial autocorrelation there must be the same number
# of observations in each year (12) - could either pad start and end years 
# with NAs or truncate.
```

Plot the Seasonal Kendall results: need to rescale the slope and intercept 
because they are based on time starting at time zero, and in units/year.
The date scale starts at `as.numeric(min(fraser_hope_arsenic$Date))` and increments by one per day

```{r}
slope <- ks_fraser$estimate["slope"] / 365
# The overall intercept is the median of all seasonal intercepts... doesn't seem
# right
int <- ks_fraser$estimate["intercept"] - 
  (slope * min(as.numeric(fraser_hope_arsenic$Date)))

k_fraser <- kendallTrendTest(fraser_hope_arsenic$month_avg, 
                             as.numeric(fraser_hope_arsenic$Date))

int <- k_fraser$estimate["intercept"] - 
  (slope * min(as.numeric(fraser_hope_arsenic$Date)))
  

ggplot(fraser_hope_arsenic, aes(x = Date, y = month_avg)) + 
  geom_point() + 
  geom_abline(slope = slope, 
              intercept = int)

# plotting on a sequence scale (as the MK test is done on) produces the same 
# figure, so I think I am transforming the slope and intercept correctly.
plot(fraser_hope_arsenic$month_avg ~ seq_len(nrow(fraser_hope_arsenic)))
abline(ks_fraser$estimate["intercept"], ks_fraser$estimate["slope"])

```

```{r}

bc_nested <- mutate(
  bc_nested, 
  seaken = map(full_monthly, ~ {
    kendallSeasonalTrendTest(.x$month_avg, season = .x$month, 
                             year = .x$year)
  }), 
  sig = map(seaken, list("p.value", 2)), 
  slope = map(seaken, list("estimate", "slope")), 
  smk_plot = pmap(
    list(d = full_monthly, m = seaken, s = SITE_NO, 
         v = PARAM_SHORT_NAME), function(d, m, s, v) {
           plot_smk(d, m, "month_avg", "Date") + 
             labs(title = paste(s, v, sep = ": "), 
                  x = "Date", y = "Value")
           
         }))

pmap(list(p = bc_nested$smk_plot, s = bc_nested$SITE_NO, 
          v = bc_nested$PARAM_SHORT_NAME), 
     function(p, s, v) {
       safely(ggsave, 
              otherwise = cat(paste0(s, "-", v), 
                              file = "log.txt", append = TRUE)
              )(filename = paste0(s, "-", v, ".png"), 
                      plot = p)
     })

```

```{r}
fraser_hope_arsenic_sk <- seaken(fraser_hope_arsenic$month_avg)
fraser_hope_arsenic_sk
# seriesPlot(fraser_hope_arsenic_sk)

# non-seasonal - to get an intercept estimate. A bit of a hack, but don't know
# a better way
fraser_hope_arsenic_k2 <- kensen.test(fraser_hope_arsenic$month_avg, 
                                     t = as.numeric(fraser_hope_arsenic$Date)
)

slope <- fraser_hope_arsenic_sk$estimate["slope"] / 365

int <- fraser_hope_arsenic_k$coef[1] - 
  (slope * min(as.numeric(fraser_hope_arsenic$Date)))

ggplot(fraser_hope_arsenic, aes(x = Date, y = month_avg)) + 
  geom_point() + 
  geom_abline(slope = slope, intercept = int)
```

